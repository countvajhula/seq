#lang racket/base

(module+ test
  (require rackunit)
  (require racket/stream)
  (require racket/set)
  (require racket/function)
  (require (except-in data/collection
                      foldl
                      foldl/steps
                      append
                      index-of))
  (require relation)
  (require functional-utils))

;; Code here

(require "utils.rkt")

(provide (all-from-out "utils.rkt"))

(module+ test
  ;; Any code in this `test` submodule runs when this file is run using DrRacket
  ;; or with `raco test`. The code here does not run when this file is
  ;; required by another module.

  (check-equal? (->list (every 3 (list 1 2 3 4 5 6 7 8))) '(1 4 7))
  (check-equal? (->list (take-while even? (stream 2 4 1 3 5))) '(2 4))
  (check-equal? (->list (take-while even? (stream 1 3 5))) '())
  (check-equal? (->list (take-while odd? (stream 1 3 5))) '(1 3 5))
  (check-equal? (->list (take-until odd? (stream 2 4 1 3 5))) '(2 4))
  (check-equal? (->list (drop-while even? (stream 2 4 1 3 5))) '(1 3 5))
  (check-equal? (->list (drop-while even? (stream 1 3 5))) '(1 3 5))
  (check-equal? (->list (drop-while odd? (stream 1 3 5))) '())
  (check-equal? (->list (drop-until odd? (stream 2 4 1 3 5))) '(1 3 5))
  (check-equal? (->list (drop-until odd? (stream 2 4))) '())
  (check-equal? (->list (drop-until even? (stream 2 4))) '(2 4))
  (check-equal? (deduplicate (list "hello" "Hello")) (list "hello" "Hello"))
  (check-equal? (deduplicate #:key string-upcase (list "hello" "Hello")) (list "hello"))
  (check-equal? (deduplicate (list 1 2 "hi" "hi" 2 3 "hello" 4 "hello" "bye")) (list 1 2 "hi" 3 "hello" 4 "bye"))
  (check-equal? (starts-with? "hello" "hello there") #t)
  (check-equal? (starts-with? "h" "hello there") #t)
  (check-equal? (starts-with? "ello" "hello there") #f)
  (check-equal? (starts-with? "Hello" "hello there") #f)
  (check-equal? (starts-with? "Hello" "") #f)
  (check-equal? (starts-with? "" "Hello") #t)
  (check-equal? (starts-with? (list 1 2) (list 1 2 3 4 5)) #t)
  (check-equal? (starts-with? (list 2 1) (list 1 2 3 4 5)) #f)
  (check-equal? (starts-with? #:key (.. string-upcase ->string) "Hello" "hello there") #t)
  (check-equal? (ends-with? "there" "hello there") #t)
  (check-equal? (ends-with? "ere" "hello there") #t)
  (check-equal? (ends-with? "ther" "hello there") #f)
  (check-equal? (ends-with? "THERE" "hello there") #f)
  (check-equal? (ends-with? "Hello" "") #f)
  (check-equal? (ends-with? "" "Hello") #t)
  (check-equal? (ends-with? (list 5) (list 1 2 3 4 5)) #t)
  (check-equal? (ends-with? #:key (.. string-upcase ->string) "THERE" "hello there") #t)
  (check-equal? (find "ello" "hello there") 1)
  (check-equal? (find " " "hello there") 5)
  (check-equal? (find "elo" "hello there") #f)
  (check-equal? (find "Ello" "hello there") #f)
  (check-equal? (find "Hello" "") #f)
  (check-equal? (find "" "Hello") 0)
  (check-equal? (find (list 1 2) (list 1 2 3 4 5)) 0)
  (check-equal? (find (list 2 1) (list 1 2 3 4 5)) #f)
  (check-equal? (find #:key (.. string-upcase ->string) "Ello" "hello there") 1)
  (check-equal? (replace "ello" "blah" "hello there") "hblah there")
  (check-equal? (replace " " ", " "hello there") "hello, there")
  (check-equal? (replace "elo" "boop" "hello there") "hello there")
  (check-equal? (replace "Ello" "blah" "hello there") "hello there")
  (check-equal? (replace "Hello" "Hi" "") "")
  ;; (check-equal? (->string (replace "Hello" "" "Hi")) "HiHello") ; contractually exclude this
  (check-equal? (->list (replace (list 1 2) (list 9 10) (list 1 2 3 4 5))) (list 9 10 3 4 5))
  (check-equal? (replace (list 2 1) (list 9 10) (list 1 2 3 4 5)) (list 1 2 3 4 5))
  (check-equal? (replace #:key (.. string-upcase ->string) "Ello" "blah" "hello there") "hblah there")
  (check-equal? (contains? "ello" "hello there") #t)
  (check-equal? (contains? " " "hello there") #t)
  (check-equal? (contains? "elo" "hello there") #f)
  (check-equal? (contains? "Ello" "hello there") #f)
  (check-equal? (contains? "Hello" "") #f)
  (check-equal? (contains? "" "Hello") #t)
  (check-equal? (contains? (list 1 2) (list 1 2 3 4 5)) #t)
  (check-equal? (contains? (list 2 1) (list 1 2 3 4 5)) #f)
  (check-equal? (contains? #:key (.. string-upcase ->string) "Ello" "hello there") #t)
  (check-equal? (trim-if negative? (list)) (list))
  (check-equal? (trim-if negative? (list 1 2 3)) (list 1 2 3))
  (check-equal? (trim-if negative? (list -1 -2 1 2 3 -3)) (list 1 2 3))
  (check-equal? (trim-if negative? #:side 'left (list -1 -2 1 2 3 -3)) (list 1 2 3 -3))
  (check-equal? (trim-if negative? #:side 'right (list -1 -2 1 2 3 -3)) (list -1 -2 1 2 3))
  (check-equal? (trim-if (curry = 5) (list 1 2 3 4 5)) (list 1 2 3 4))
  (check-equal? (trim-if (curry = 5) (list 5 5 1 2 3 4 5 5 5)) (list 1 2 3 4))
  (check-equal? (trim-if char-whitespace? "   \thello\n  ") "hello")
  (check-equal? (trim-if char-whitespace? "   \thello\n  " #:how-many #f) "hello")
  (check-equal? (trim-if char-whitespace? "  \thello\n  " #:how-many 1) " \thello\n ")
  (check-equal? (trim-if char-whitespace? "   \thello\n   " #:how-many 2) " \thello\n ")
  (check-equal? (trim 0 (list)) (list))
  (check-equal? (trim 0 (list 1 2 3)) (list 1 2 3))
  (check-equal? (trim 0 (list 0 1 2 3 0 0)) (list 1 2 3))
  (check-equal? (trim 0 #:side 'left (list 0 1 2 3 0 0)) (list 1 2 3 0 0))
  (check-equal? (trim 0 #:side 'right (list 0 1 2 3 0 0)) (list 0 1 2 3))
  (check-equal? (trim #\space "   \thello\n  ") "\thello\n")
  (check-equal? (trim " " "   \thello\n  ") "\thello\n")
  (check-equal? (trim "h" "hellohhh") "ello")
  (check-equal? (trim #\h "hellohhh") "ello")
  (check-equal? (->list (split-when (curry = #\space) "hello there")) (list "hello" "there"))
  (check-equal? (->list (split-when (curry = #\space) " ")) (list ""))
  (check-equal? (->list (split-when #:trim? #f (curry = #\space) " ")) (list "" ""))
  (check-equal? (->list (split-when (curry = #\space) "")) (list ""))
  (check-equal? (->list (map ->list (split-when (curry = 1) (list 2 1 2)))) '((2) (2)))
  (check-equal? (->list (map ->list (split-when (curry = 1) (list 2)))) '((2)))
  (check-equal? (->list (split-when (curry = 1) (list))) (list ID))
  (check-equal? (->list (map ->list (split 5 (list 1 2 5 2 3 5 6 5 7 8)))) '((1 2) (2 3) (6) (7 8)))
  (check-equal? (->list (map ->list (split 5 (list)))) '(()))
  (check-equal? (->list (map ->list (split 5 (list 1)))) '((1)))
  (check-equal? (->list (map ->list (split 5 (list 5)))) '(()))
  (check-equal? (->list (map ->list (split #:trim? #f 5 (list 5)))) '(() ()))
  (check-equal? (->list (map ->list (split 5 (list 1 2 3)))) '((1 2 3)))
  (check-equal? (->list (map ->list (split #:trim? #t 5 (list 5 5 5 1 2 5 2 3 5 6 5 7 8 5 5 5)))) '((1 2) (2 3) (6) (7 8)))
  (check-equal? (->list (map ->list (split #:trim? #f 5 (list 5 5 5 1 2 5 2 3 5 6 5 7 8 5 5 5)))) '(() () () (1 2) (2 3) (6) (7 8) () () ()))
  (check-equal? (->list (map ->list (split #:trim? #t 5 (list 5 5 5 1 2 5 5 2 3 5 6 5 7 8 5 5 5)))) '((1 2) () (2 3) (6) (7 8)))
  (check-equal? (->list (map ->list (split 5 (list 1 2 5 2 3 5 6 5)))) '((1 2) (2 3) (6)))
  (check-equal? (->list (map ->list (split #:trim? #f 5 (list 1 2 5 2 3 5 6 5)))) '((1 2) (2 3) (6) ()))
  (check-equal? (->list (split "\n" "hello\n there")) (list "hello" " there") "split string handles string separator as char")
  (check-equal? (let-values ([(a b)
                              (split-at 2 (list 1 3 5 2 4))])
                  (->list (map ->list (list a b))))
                (list '(1 3) '(5 2 4)))
  (check-equal? (let-values ([(a b)
                              (split-at 5 "hellothere")])
                  (list a b))
                (list "hello" "there"))
  (check-equal? (let-values ([(a b)
                              (split-where odd? (list 1 3 5 2 4))])
                  (->list (map ->list (list a b))))
                (list '() '(1 3 5 2 4)))
  (check-equal? (let-values ([(a b)
                              (split-where even? (list 1 3 5 2 4))])
                  (->list (map ->list (list a b))))
                (list '(1 3 5) '(2 4)))
  (check-equal? (->list (add-between 'and (stream 'a 'b 'c))) '(a and b and c))
  (check-equal? (weave (stream "hi" "there") "\n") "hi\nthere")
  (check-equal? (weave (stream (list 1 2) (list 3 4)) (list 9)) (list 1 2 9 3 4))
  (check-equal? ((weave (list add1 sub1) add1) 5) 6)
  (check-equal? (->list (zip list (list 1 2 3) (list 1 2 3))) '((1 1) (2 2) (3 3)))
  (check-equal? (->list (zip list (list 1 2 3) (list 1 2 3) (list 1 2 3))) '((1 1 1) (2 2 2) (3 3 3)))
  (check-equal? (->list (zip list (list 1 2 3))) '((1) (2) (3)))
  (check-equal? (->list (zip list (list) (list))) '())
  (check-equal? (->list (zip string "hello" "there")) (list "ht" "eh" "le" "lr" "oe"))
  (check-equal? (->list (zip list (list 1 2 3) (list 1 2 3 4))) '((1 1) (2 2) (3 3)) "sequences of unequal length")
  (check-equal? (->list (zip list (list 1 2 3 4) (list 1 2 3))) '((1 1) (2 2) (3 3)) "sequences of unequal length")
  (check-equal? (->list (zip list (naturals) (list 'a 'b 'c))) '((0 a) (1 b) (2 c)))
  (check-equal? (index-of 2 (list)) #f)
  (check-equal? (index-of 2 (list 2)) 0)
  (check-equal? (index-of 2 (list 1 2)) 1)
  (check-equal? (index-of 3 (list 1 2)) #f)
  (check-equal? (index-of 2 (list 1 2 2 1)) 1)
  (check-equal? (index-of 2 (stream 1 2 2 1)) 1)
  (check-equal? (index-of #:key even? 2 (list 1 4 2 3 6)) 1)
  (check-equal? (index-of #:key string-upcase "BANANA" (list "apple" "banana" "cherry")) 1)
  (check-equal? (->list (remove 2 (list 2))) '())
  (check-equal? (->list (remove 2 (list 2 1))) (list 1))
  (check-equal? (->list (remove 2 (list 1 2))) (list 1))
  (check-equal? (->list (remove 2 (list 1 2 2 1))) (list 1 1))
  (check-equal? (->list (remove 2 (stream 1 2 2 1))) (list 1 1))
  (check-equal? (->list (remove #:how-many 1 2 (list 1 2 2 1))) (list 1 2 1))
  (check-equal? (->list (remove #:how-many 2 2 (list 1 2 2 1 2))) (list 1 1 2))
  (check-equal? (->list (remove #:key even? 2 (list 1 2 4 3 6))) (list 1 3))
  (check-equal? (->list (remove #:key even? #:how-many 2 2 (list 1 2 4 3 6))) (list 1 3 6))
  (check-equal? (remove "banana" (set "apple" "banana" "cherry")) (set "apple" "cherry"))
  (check-equal? (remove "BANANA" (generic-set #:key string-upcase "apple" "banana" "cherry")) (generic-set #:key string-upcase "apple" "cherry"))
  (check-equal? (remove "a" "aaahai athaerea") "hi there")
  (check-equal? (remove #\a "aaahai athaerea") "hi there")
  (check-equal? (->list (remove-when odd? (list 2))) (list 2))
  (check-equal? (->list (remove-when even? (list 2))) '())
  (check-equal? (->list (remove-when even? (list 2 1))) (list 1))
  (check-equal? (->list (remove-when even? (list 1 2))) (list 1))
  (check-equal? (->list (remove-when even? (list 1 2 2 1))) (list 1 1))
  (check-equal? (->list (remove-when even? (stream 1 2 2 1))) (list 1 1))
  (check-equal? (->list (remove-when even? #:how-many 1 (list 1 2 2 1))) (list 1 2 1))
  (check-equal? (->list (remove-when even? #:how-many 2 (list 1 2 2 1 2))) (list 1 1 2))
  (check-equal? (->list (remove-when even? (list 1 2 4 3 6))) (list 1 3))
  (check-equal? (->list (remove-when even? #:how-many 2 (list 1 2 4 3 6))) (list 1 3 6))
  (check-exn exn:fail:contract?
             (thunk (remove-when (curry = "banana") (set "apple" "banana" "cherry"))) (set "apple" "cherry"))
  (check-exn exn:fail:contract?
             (thunk (remove-when (curry = "BANANA") (generic-set #:key string-upcase "apple" "banana" "cherry"))))
  (let ([t (list 1
                 (list 2
                       (list 3)
                       (list 4))
                 (list 5
                       (list 6)
                       (list 7))
                 (list 8
                       (list 9
                             (list 10)
                             (list 11))
                       (list 12
                             (list 13)
                             (list 14))))]
        [empty-tree (list)]
        [leaf-tree (list 1)])
    (check-equal? (->list (tree-traverse t #:order 'pre))
                  (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14))
    (check-equal? (->list (tree-traverse empty-tree #:order 'pre))
                  (list))
    (check-equal? (->list (tree-traverse leaf-tree #:order 'pre))
                  (list 1))
    (check-equal? (->list (tree-traverse t #:order 'pre #:converse? #t))
                  (list 1 8 12 14 13 9 11 10 5 7 6 2 4 3))
    (check-equal? (->list (tree-traverse empty-tree #:order 'pre #:converse? #t))
                  (list))
    (check-equal? (->list (tree-traverse leaf-tree #:order 'pre #:converse? #t))
                  (list 1))
    (check-equal? (->list (tree-traverse t #:order 'post))
                  (list 3 4 2 6 7 5 10 11 9 13 14 12 8 1))
    (check-equal? (->list (tree-traverse empty-tree #:order 'post))
                  (list))
    (check-equal? (->list (tree-traverse leaf-tree #:order 'post))
                  (list 1))
    (check-equal? (->list (tree-traverse t #:order 'post #:converse? #t))
                  (list 14 13 12 11 10 9 8 7 6 5 4 3 2 1))
    (check-equal? (->list (tree-traverse empty-tree #:order 'post #:converse? #t))
                  (list))
    (check-equal? (->list (tree-traverse leaf-tree #:order 'post #:converse? #t))
                  (list 1))
    (check-equal? (->list (tree-traverse t #:order 'in))
                  (list 3 2 4 1 6 5 7 10 9 11 8 13 12 14))
    (check-equal? (->list (tree-traverse empty-tree #:order 'in))
                  (list))
    (check-equal? (->list (tree-traverse leaf-tree #:order 'in))
                  (list 1))
    (check-equal? (->list (tree-traverse t #:order 'in #:converse? #t))
                  (list 14 12 13 8 11 9 10 1 7 5 6 4 2 3))
    (check-equal? (->list (tree-traverse empty-tree #:order 'in #:converse? #t))
                  (list))
    (check-equal? (->list (tree-traverse leaf-tree #:order 'in #:converse? #t))
                  (list 1))
    (check-equal? (->list (tree-traverse t #:order 'level))
                  (list 1 2 5 8 3 4 6 7 9 12 10 11 13 14))
    (check-equal? (->list (tree-traverse empty-tree #:order 'level))
                  (list))
    (check-equal? (->list (tree-traverse leaf-tree #:order 'level))
                  (list 1))
    (check-equal? (->list (tree-traverse t #:order 'level #:converse? #t))
                  (list 1 8 5 2 12 9 7 6 4 3 14 13 11 10))
    (check-equal? (->list (tree-traverse empty-tree #:order 'level #:converse? #t))
                  (list))
    (check-equal? (->list (tree-traverse leaf-tree #:order 'level #:converse? #t))
                  (list 1))
    (check-equal? (->list (tree-traverse (make-tree (unthunk (->generator (take 3 (repeat (list 1 2))) '())) 5)))
                  (list 5 1 1 1 2 2 2))
    (check-equal? (->list (tree-traverse (tree-map add1 t)))
                  (list 2 3 4 5 6 7 8 9 10 11 12 13 14 15))
    (check-equal? (->list (tree-traverse (tree-map add1 empty-tree)))
                  (list))
    (check-equal? (->list (tree-traverse (tree-map add1 leaf-tree)))
                  (list 2))
    (check-equal? (->list (tree-traverse (tree-filter (curryr < 7) t)))
                  (list 1 2 3 4 5 6))
    (check-equal? (->list (tree-traverse (tree-filter (curryr < 7) empty-tree)))
                  (list))
    (check-equal? (->list (tree-traverse (tree-filter (curryr < 7) leaf-tree)))
                  (list 1))
    (check-equal? (tree-fold + t) 105)
    (check-equal? (tree-fold + empty-tree) ID)
    (check-equal? (tree-fold + leaf-tree) 1)
    (check-equal? (tree-fold + t 1) 106)
    (check-equal? (->list (tree-fold + t #:order 'pre #:with-steps? #t))
                  (list 0 1 3 6 10 15 21 28 36 45 55 66 78 91 105))
    (check-equal? (->list (tree-fold + t #:order 'pre #:converse? #t #:with-steps? #t))
                  (list 0 1 9 21 35 48 57 68 78 83 90 96 98 102 105))
    (check-equal? (->list (tree-fold + t #:order 'post #:with-steps? #t))
                  (list 0 3 7 9 15 22 27 37 48 57 70 84 96 104 105))
    (check-equal? (->list (tree-fold + t #:order 'in #:with-steps? #t))
                  (list 0 3 5 9 10 16 21 28 38 47 58 66 79 91 105))
    (check-equal? (->list (tree-fold + t #:order 'level #:with-steps? #t))
                  (list 0 1 3 8 16 19 23 29 36 45 57 67 78 91 105))))

(module+ main
  ;; (Optional) main submodule. Put code here if you need it to be executed when
  ;; this file is run using DrRacket or the `racket` executable.  The code here
  ;; does not run when this file is required by another module. Documentation:
  ;; http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._main-and-test%29

  (require racket/cmdline)
  (define who (box "world"))
  (command-line
    #:program "my-program"
    #:once-each
    [("-n" "--name") name "Who to say hello to" (set-box! who name)]
    #:args ()
    (printf "hello ~a~n" (unbox who))))
